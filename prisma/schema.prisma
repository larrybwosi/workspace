// ============================================
// CONFIGURATION
// ============================================

generator client {
  provider = "prisma-client-js"
  // output   = "../prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// AUTH MODELS (Better Auth)
// ============================================

model User {
  id            String   @id @default(cuid())
  name          String
  email         String   @unique
  emailVerified Boolean  @default(false)
  image         String?
  avatar        String?
  role          String   @default("Development")
  status        String   @default("online")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Auth Relations
  verification Verification[]
  sessions     Session[]
  accounts     Account[]
  apiKeys      ApiKey[]

  // Workspace Relations
  ownedWorkspaces              Workspace[]           @relation("WorkspaceOwner")
  workspaceMemberships         WorkspaceMember[]
  sentWorkspaceInvitations     WorkspaceInvitation[] @relation("WorkspaceInviter")
  receivedWorkspaceInvitations WorkspaceInvitation[] @relation("WorkspaceInvitedUser")
  workspaceApiTokens           WorkspaceApiToken[]

  // Communication Relations
  messages       Message[]
  threads        Thread[]        @relation("ThreadCreator")
  threadMembers  Thread[]        @relation("ThreadMembers")
  comments       Comment[]
  channelMembers ChannelMember[]
  createdChannels Channel[]     @relation("ChannelCreator")

  // Task & Project Relations
  tasks           Task[]    @relation("TaskAssignees")
  createdTasks    Task[]    @relation("TaskCreator")
  watchedTasks    Task[]    @relation("TaskWatchers")
  projects        Project[] @relation("ProjectMembers")
  createdProjects Project[] @relation("ProjectCreator")

  // Note Relations
  notes             Note[]        @relation("NoteCreator")
  noteCollaborators Note[]        @relation("NoteCollaborators")
  createdFolders    NoteFolder[]
  noteVersions      NoteVersion[]

  // Calendar & Event Relations
  sprintMembers         Sprint[]               @relation("SprintMembers")
  eventAttendees        CalendarEvent[]        @relation("EventAttendees")
  createdEvents         CalendarEvent[]        @relation("EventCreator")
  timeEntries           TimeEntry[]
  calendarIntegrations  CalendarIntegration[]
  calendarSubscriptions CalendarSubscription[]
  calendarShares        CalendarShare[]
  eventReminders        EventReminder[]

  // Notification & System Relations
  notifications          Notification[]
  activityLogs           ActivityLog[]
  scheduledNotifications ScheduledNotification[]
  deviceTokens           DeviceToken[]
  pushNotificationLogs   PushNotificationLog[]
  webhooks               Webhook[]

  // AI Assistant Relations
  assistantConversations AssistantConversation[]
  assistantAuditLogs     AssistantAuditLog[]

  // Calls & DM Relations
  calls            Call[]
  callParticipants CallParticipant[]
  messageReads     MessageRead[]
  dmMessageReads   DMMessageRead[]
  reactions        Reaction[]
  dmReactions      DMReaction[]

  // Invitation Relations (General)
  sentInvitations Invitation[] @relation("InvitedBy")

  // DM Relations
  dmParticipant1 DirectMessage[] @relation("DMParticipant1")
  dmParticipant2 DirectMessage[] @relation("DMParticipant2")
  dmMessages     DMMessage[]

  teamMemberships WorkspaceTeamMember[]
  announcements   DepartmentAnnouncement[]

  // Enterprise Project Management
  resourceAllocations ResourceAllocation[]
  projectReports      ProjectReport[]
  statusUpdates       ProjectStatusUpdate[]
  createdTemplates    ProjectTemplate[]

  // Social & Webhooks (Added for consistency with lower models)
  friends                Friend[]         @relation("UserFriends")
  friendOf               Friend[]         @relation("FriendOf")
  sentFriendRequests     FriendRequest[]  @relation("SentFriendRequests")
  receivedFriendRequests FriendRequest[]  @relation("ReceivedFriendRequests")
  createdChannelWebhooks ChannelWebhook[]
  createdIncomingWebhooks ChannelIncomingWebhook[] @relation(fields: [], references: [])

  banned     Boolean?  @default(false)
  banReason  String?
  banExpires DateTime?

  @@map("users")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  userId     String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([identifier, value])
  @@map("verifications")
  @@index([identifier])
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  impersonatedBy String?

  @@map("sessions")
  @@index([userId])
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("account")
  @@index([userId])
}

// ============================================
// WORKSPACE MODELS
// ============================================

model Workspace {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  icon        String?
  description String?
  ownerId     String
  plan        String   @default("free") // free, pro, enterprise
  settings    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner User @relation("WorkspaceOwner", fields: [ownerId], references: [id])

  members      WorkspaceMember[]
  projects     Project[]
  channels     Channel[]
  notes        Note[]
  invitations  WorkspaceInvitation[]
  webhooks     WorkspaceWebhook[]
  integrations WorkspaceIntegration[]
  auditLogs    WorkspaceAuditLog[]
  customEmojis CustomEmoji[]
  userBadges   UserBadge[]
  departments  WorkspaceDepartment[]
  teams        WorkspaceTeam[]
  apiTokens    WorkspaceApiToken[]

  // Enterprise relations
  projectTemplates ProjectTemplate[]
  projectReports   ProjectReport[]
  statusUpdates    ProjectStatusUpdate[]

  @@map("workspaces")
}

model WorkspaceDepartment {
  id          String   @id @default(cuid())
  workspaceId String
  name        String
  slug        String
  description String?
  icon        String?
  color       String?
  parentId    String? // For nested departments
  managerId   String? // Department head
  settings    Json? // Department-specific settings
  channelId   String? // Default department channel
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  workspace     Workspace                @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  parent        WorkspaceDepartment?     @relation("DepartmentHierarchy", fields: [parentId], references: [id])
  children      WorkspaceDepartment[]    @relation("DepartmentHierarchy")
  members       WorkspaceMember[]
  teams         WorkspaceTeam[]
  announcements DepartmentAnnouncement[]

  @@unique([workspaceId, slug])
  @@map("workspace_departments")
}

model WorkspaceTeam {
  id           String   @id @default(cuid())
  workspaceId  String
  departmentId String?
  name         String
  slug         String
  description  String?
  icon         String?
  color        String?
  leadId       String? // Team lead
  settings     Json?
  channelId    String? // Team channel
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  workspace  Workspace             @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  department WorkspaceDepartment?  @relation(fields: [departmentId], references: [id])
  members    WorkspaceTeamMember[]

  @@unique([workspaceId, slug])
  @@map("workspace_teams")
}

model WorkspaceTeamMember {
  id       String   @id @default(cuid())
  teamId   String
  userId   String
  role     String   @default("member") // lead, member
  joinedAt DateTime @default(now())

  team WorkspaceTeam @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@map("workspace_team_members")
}

model DepartmentAnnouncement {
  id             String    @id @default(cuid())
  departmentId   String
  authorId       String
  title          String
  content        String
  priority       String    @default("normal") // low, normal, high, urgent
  pinned         Boolean   @default(false)
  publishAt      DateTime?
  expiresAt      DateTime?
  targetAudience Json? // { departments: [], teams: [], roles: [] }
  attachments    Json?
  reactions      Json?
  readBy         String[]  @default([])
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  department WorkspaceDepartment @relation(fields: [departmentId], references: [id], onDelete: Cascade)
  author     User                @relation(fields: [authorId], references: [id])

  @@map("department_announcements")
}

model WorkspaceApiToken {
  id          String    @id @default(cuid())
  workspaceId String
  name        String
  token       String    @unique
  permissions Json // { departments: [...], teams: [...], actions: [...] }
  rateLimit   Int       @default(1000)
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  usageCount  Int       @default(0)
  createdById String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  createdBy User      @relation(fields: [createdById], references: [id])

  @@map("workspace_api_tokens")
}

model WorkspaceMember {
  id           String   @id @default(cuid())
  workspaceId  String
  userId       String
  departmentId String?
  role         String   @default("member")
  joinedAt     DateTime @default(now())

  workspace  Workspace            @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user       User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  department WorkspaceDepartment? @relation(fields: [departmentId], references: [id])

  @@unique([workspaceId, userId])
  @@map("workspace_members")
}

model WorkspaceInvitation {
  id          String    @id @default(cuid())
  workspaceId String
  email       String
  userId      String? // For linking to existing users if known
  token       String    @unique
  role        String    @default("member")
  invitedBy   String
  status      String    @default("pending") // pending, accepted, declined, expired
  permissions Json?
  expiresAt   DateTime
  acceptedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  inviter   User      @relation("WorkspaceInviter", fields: [invitedBy], references: [id])
  user      User?     @relation("WorkspaceInvitedUser", fields: [userId], references: [id])

  @@index([email])
  @@index([workspaceId])
  @@map("workspace_invitations")
}

model WorkspaceWebhook {
  id          String   @id @default(cuid())
  workspaceId String
  name        String
  url         String
  secret      String
  events      String[] // Array of event types
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())

  workspace Workspace             @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  logs      WorkspaceWebhookLog[]

  @@map("workspace_webhooks")
}

model WorkspaceWebhookLog {
  id        String   @id @default(cuid())
  webhookId String
  event     String
  payload   Json
  response  Json?
  success   Boolean
  createdAt DateTime @default(now())

  webhook WorkspaceWebhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  @@map("workspace_webhook_logs")
}

model WorkspaceIntegration {
  id          String   @id @default(cuid())
  workspaceId String
  service     String // slack, github, jira, etc.
  config      Json
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@map("workspace_integrations")
}

model WorkspaceAuditLog {
  id          String   @id @default(cuid())
  workspaceId String
  userId      String
  action      String
  resource    String
  resourceId  String?
  metadata    Json?
  createdAt   DateTime @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@map("workspace_audit_logs")
}

// ============================================
// CHANNEL & MESSAGING MODELS
// ============================================

model Channel {
  id          String   @id @default(cuid())
  name        String
  icon        String
  type        String   @default("channel")
  description String?
  isPrivate   Boolean  @default(false)
  parentId    String?
  workspaceId String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  parent    Channel?   @relation("ChannelHierarchy", fields: [parentId], references: [id])
  children  Channel[]  @relation("ChannelHierarchy")
  workspace Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  threads  Thread[]
  messages Message[] 
  members  ChannelMember[]
  projects Project[]       @relation("ProjectChannels")
  incomingWebhooks ChannelIncomingWebhook[] @relation(fields: [], references: [])

  invitations           Invitation[]
  calendarSubscriptions CalendarSubscription[]
  webhooks              ChannelWebhook[]

  createdById String?
  createdBy   User? @relation("ChannelCreator", fields: [createdById], references: [id])

  @@map("channels")
}

model ChannelMember {
  id        String   @id @default(cuid())
  channelId String
  userId    String
  role      String   @default("member")
  joinedAt  DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([channelId, userId])
  @@map("channel_members")
}

model Thread {
  id          String   @id @default(cuid())
  channelId   String
  creatorId   String
  status      String   @default("Active")
  dateCreated DateTime @default(now())
  updatedAt   DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  creator User    @relation("ThreadCreator", fields: [creatorId], references: [id])



  // ✅ 1. Metadata is optional now
  // Slack threads don't usually have titles. Discord threads do.
  // Make title optional to support both styles.
  title       String?  


  // ✅ 3. The "Root" Message (Discord Style)
  // This helps you render: "Thread started from: [Message Preview]"
  rootMessageId String? @unique 
  rootMessage   Message? @relation("ThreadRoot", fields: [rootMessageId], references: [id])

  participants User[]    @relation("ThreadMembers")
  messages Message[]
  tags     ThreadTag[]
  tasks    Task[]      @relation("TaskLinkedThreads")

  @@map("threads")
}

model ThreadTag {
  id       String @id @default(cuid())
  threadId String
  tag      String

  thread Thread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@unique([threadId, tag])
  @@map("thread_tags")
}

model Message {
  id          String   @id @default(cuid())
  userId      String
  content     String   @db.Text
  messageType String   @default("standard")
  metadata    Json?
  isEdited    Boolean  @default(false)
  depth       Int      @default(0)
  timestamp   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Opposite relation field for Thread's rootMessage
  rootThread  Thread?  @relation("ThreadRoot")

  // ✅ 1. Direct Link to Channel (The "Main Feed")
  // This allows you to fetch "all messages in #general" instantly.
  channelId String
  channel   Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  // ✅ 2. Optional Thread Link
  // If null, it's a main channel message. If set, it's a reply inside a thread.
  threadId  String?
  thread    Thread? @relation(fields: [threadId], references: [id], onDelete: Cascade)

  // ✅ 3. Hierarchy (Optional but Recommended)
  // Useful for "Slack-style" threading where you don't always create a full "Thread" entity
  // immediately, or just to know which message started the conversation.
  replyToId String?
  replyTo   Message?  @relation("MessageReplies", fields: [replyToId], references: [id])
  replies   Message[] @relation("MessageReplies")
  user    User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  reactions   Reaction[]
  attachments Attachment[]
  mentions    MessageMention[]
  readBy      MessageRead[]

  @@map("messages")
}

model MessageRead {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
  @@map("message_reads")
}

model Reaction {
  id            String   @id @default(cuid())
  messageId     String
  userId        String
  emoji         String
  customEmojiId String?
  createdAt     DateTime @default(now())

  message     Message      @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  customEmoji CustomEmoji? @relation(fields: [customEmojiId], references: [id])

  @@unique([messageId, userId, emoji])
  @@map("reactions")
}

model MessageMention {
  id        String @id @default(cuid())
  messageId String
  mention   String

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@map("message_mentions")
}

model Attachment {
  id        String   @id @default(cuid())
  messageId String?
  noteId    String?
  taskId    String?
  name      String
  type      String
  url       String
  size      String?
  createdAt DateTime @default(now())

  message Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)
  note    Note?    @relation(fields: [noteId], references: [id], onDelete: Cascade)
  task    Task?    @relation("TaskAttachments", fields: [taskId], references: [id], onDelete: Cascade)

  @@map("attachments")
}

model DirectMessage {
  id             String    @id @default(cuid())
  participant1Id String
  participant2Id String
  lastMessageAt  DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  participant1 User @relation("DMParticipant1", fields: [participant1Id], references: [id], onDelete: Cascade)
  participant2 User @relation("DMParticipant2", fields: [participant2Id], references: [id], onDelete: Cascade)

  messages DMMessage[]

  @@unique([participant1Id, participant2Id])
  @@index([participant1Id])
  @@index([participant2Id])
  @@map("direct_messages")
}

model DMMessage {
  id        String   @id @default(cuid())
  dmId      String
  senderId  String
  content   String   @db.Text
  isEdited  Boolean  @default(false)
  replyToId String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  dm      DirectMessage @relation(fields: [dmId], references: [id], onDelete: Cascade)
  sender  User          @relation(fields: [senderId], references: [id], onDelete: Cascade)
  replyTo DMMessage?    @relation("DMMessageReplies", fields: [replyToId], references: [id])
  replies DMMessage[]   @relation("DMMessageReplies")

  attachments DMAttachment[]
  reactions   DMReaction[]
  readBy      DMMessageRead[]

  @@index([dmId])
  @@index([senderId])
  @@map("dm_messages")
}

model DMMessageRead {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())

  message DMMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
  @@map("dm_message_reads")
}

model DMReaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  emoji     String
  createdAt DateTime @default(now())

  message DMMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@map("dm_reactions")
}

model DMAttachment {
  id        String   @id @default(cuid())
  messageId String
  name      String
  type      String
  url       String
  size      String?
  createdAt DateTime @default(now())

  message DMMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@map("dm_attachments")
}

// ============================================
// PROJECT & TASK MODELS
// ============================================

model Project {
  id          String   @id @default(cuid())
  name        String
  icon        String
  description String   @db.Text
  status      String   @default("active")
  startDate   DateTime
  endDate     DateTime
  creatorId   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  workspaceId String?

  creator   User       @relation("ProjectCreator", fields: [creatorId], references: [id])
  workspace Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  tasks                 Task[]
  members               User[]                 @relation("ProjectMembers")
  channels              Channel[]              @relation("ProjectChannels")
  milestones            Milestone[]
  sprints               Sprint[]
  customFields          CustomField[]
  risks                 Risk[]
  budgets               Budget[]
  notes                 Note[]                 @relation("NoteLinkedProjects")
  events                CalendarEvent[]
  invitations           Invitation[]           @relation("ProjectInvitations")
  calendarSubscriptions CalendarSubscription[]

  // New relationships for enterprise project management
  templateId String?
  template   ProjectTemplate? @relation(fields: [templateId], references: [id])

  resourceAllocations ResourceAllocation[]
  timelines           ProjectTimeline[]
  reports             ProjectReport[]
  statusUpdates       ProjectStatusUpdate[]

  @@map("projects")
}

// New model for enterprise project management

model ResourceAllocation {
  id           String    @id @default(cuid())
  projectId    String
  userId       String
  role         String // developer, designer, manager, etc.
  allocation   Float // percentage of time (0-100)
  startDate    DateTime
  endDate      DateTime?
  billableRate Float?
  cost         Float?
  notes        String?   @db.Text
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id])

  @@map("resource_allocations")
}

// New model for enterprise project management

model ProjectTimeline {
  id           String   @id @default(cuid())
  projectId    String
  title        String
  description  String?  @db.Text
  startDate    DateTime
  endDate      DateTime
  progress     Float    @default(0)
  color        String?
  dependencies String[] // Array of timeline IDs
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("project_timelines")
}

// New model for enterprise project management

model ProjectReport {
  id          String   @id @default(cuid())
  projectId   String
  workspaceId String?
  title       String
  type        String // status, velocity, burndown, cost, resource, etc.
  data        Json // Report data
  generatedBy String
  createdAt   DateTime @default(now())

  project   Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  workspace Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  generator User       @relation(fields: [generatedBy], references: [id])

  @@map("project_reports")
}

// New model for enterprise project management

model ProjectStatusUpdate {
  id           String   @id @default(cuid())
  projectId    String
  workspaceId  String?
  authorId     String
  title        String
  content      String   @db.Text
  status       String // on_track, at_risk, off_track, completed
  visibility   String   @default("team") // team, workspace, public
  notifyTeam   Boolean  @default(true)
  achievements String[] // Array of accomplishments
  challenges   String[] // Array of blockers/issues
  nextSteps    String[] // Array of upcoming actions
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  project   Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  workspace Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  author    User       @relation(fields: [authorId], references: [id])

  @@map("project_status_updates")
}

model Task {
  id             String    @id @default(cuid())
  title          String
  description    String    @db.Text
  status         String    @default("todo")
  priority       String    @default("medium")
  dueDate        DateTime?
  startDate      DateTime?
  estimatedHours Float?
  loggedHours    Float?
  progress       Float     @default(0)
  projectId      String
  sprintId       String?
  milestoneId    String?
  parentTaskId   String?
  creatorId      String
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  project    Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  sprint     Sprint?    @relation(fields: [sprintId], references: [id], onDelete: SetNull)
  milestone  Milestone? @relation(fields: [milestoneId], references: [id], onDelete: SetNull)
  parentTask Task?      @relation("TaskSubtasks", fields: [parentTaskId], references: [id])
  creator    User       @relation("TaskCreator", fields: [creatorId], references: [id])

  subtasks          Task[]             @relation("TaskSubtasks")
  assignees         User[]             @relation("TaskAssignees")
  watchers          User[]             @relation("TaskWatchers")
  tags              TaskTag[]
  comments          Comment[]
  timeEntries       TimeEntry[]
  linkedThreads     Thread[]           @relation("TaskLinkedThreads")
  dependencies      TaskDependency[]   @relation("TaskDependencies")
  dependents        TaskDependency[]   @relation("TaskDependents")
  blockers          TaskBlocker[]      @relation("TaskBlockers")
  blocking          TaskBlocker[]      @relation("TaskBlocking")
  customFieldValues CustomFieldValue[]
  notes             Note[]             @relation("NoteLinkedTasks")
  attachments       Attachment[]       @relation("TaskAttachments")
  calendarEvents    CalendarEvent[]

  @@map("tasks")
}

model TaskTag {
  id     String @id @default(cuid())
  taskId String
  tag    String

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@unique([taskId, tag])
  @@map("task_tags")
}

model TaskDependency {
  id          String @id @default(cuid())
  taskId      String
  dependsOnId String

  task      Task @relation("TaskDependencies", fields: [taskId], references: [id], onDelete: Cascade)
  dependsOn Task @relation("TaskDependents", fields: [dependsOnId], references: [id], onDelete: Cascade)

  @@unique([taskId, dependsOnId])
  @@map("task_dependencies")
}

model TaskBlocker {
  id        String  @id @default(cuid())
  taskId    String
  blockerId String
  reason    String?

  task    Task @relation("TaskBlockers", fields: [taskId], references: [id], onDelete: Cascade)
  blocker Task @relation("TaskBlocking", fields: [blockerId], references: [id], onDelete: Cascade)

  @@unique([taskId, blockerId])
  @@map("task_blockers")
}

model Comment {
  id        String   @id @default(cuid())
  taskId    String
  userId    String
  content   String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("comments")
}

model TimeEntry {
  id          String   @id @default(cuid())
  taskId      String
  userId      String
  duration    Int
  startTime   DateTime
  endTime     DateTime
  description String?
  billable    Boolean  @default(false)
  createdAt   DateTime @default(now())

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("time_entries")
}

model Milestone {
  id          String   @id @default(cuid())
  projectId   String
  title       String
  description String   @db.Text
  dueDate     DateTime
  status      String   @default("upcoming")
  progress    Float    @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  tasks   Task[]

  @@map("milestones")
}

model Sprint {
  id        String   @id @default(cuid())
  projectId String
  name      String
  goal      String   @db.Text
  startDate DateTime
  endDate   DateTime
  status    String   @default("planning")
  velocity  Float    @default(0)
  capacity  Float    @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  tasks   Task[]
  members User[]  @relation("SprintMembers")

  @@map("sprints")
}

model CustomField {
  id           String   @id @default(cuid())
  projectId    String
  name         String
  type         String
  options      Json?
  required     Boolean  @default(false)
  defaultValue String?
  entityType   String
  createdAt    DateTime @default(now())

  project Project            @relation(fields: [projectId], references: [id], onDelete: Cascade)
  values  CustomFieldValue[]

  @@map("custom_fields")
}

model CustomFieldValue {
  id            String @id @default(cuid())
  customFieldId String
  taskId        String
  value         String @db.Text

  customField CustomField @relation(fields: [customFieldId], references: [id], onDelete: Cascade)
  task        Task        @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@unique([customFieldId, taskId])
  @@map("custom_field_values")
}

model Risk {
  id          String   @id @default(cuid())
  projectId   String
  title       String
  description String   @db.Text
  impact      String
  probability String
  mitigation  String?  @db.Text
  status      String   @default("open")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("risks")
}

model Budget {
  id        String   @id @default(cuid())
  projectId String
  category  String
  allocated Float
  spent     Float    @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("budgets")
}

model ProjectTemplate {
  id          String   @id @default(cuid())
  name        String
  description String   @db.Text
  category    String // development, marketing, sales, operations, etc.
  icon        String?
  workspaceId String?
  isPublic    Boolean  @default(false)
  metadata    Json? // Template configuration
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  workspace Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  createdBy User       @relation(fields: [createdById], references: [id])
  projects  Project[]

  @@map("project_templates")
}

// ============================================
// CALENDAR INTEGRATION MODELS
// ============================================

model CalendarIntegration {
  id           String    @id @default(cuid())
  userId       String
  provider     String // google, outlook, apple
  accountEmail String
  accessToken  String    @db.Text
  refreshToken String?   @db.Text
  expiresAt    DateTime?
  calendarId   String?
  calendarName String?
  syncEnabled  Boolean   @default(true)
  lastSyncAt   DateTime?
  settings     Json?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user  User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  syncs CalendarSync[]

  @@index([userId])
  @@index([provider])
  @@map("calendar_integrations")
}

model CalendarSync {
  id              String   @id @default(cuid())
  integrationId   String
  eventId         String // our internal event ID
  externalEventId String // external calendar event ID
  provider        String
  lastSynced      DateTime @default(now())
  syncStatus      String   @default("synced") // synced, pending, error
  errorMessage    String?  @db.Text

  integration CalendarIntegration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  event       CalendarEvent       @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([integrationId, externalEventId])
  @@index([eventId])
  @@map("calendar_syncs")
}

model CalendarSubscription {
  id          String   @id @default(cuid())
  userId      String
  projectId   String?
  channelId   String?
  name        String
  description String?
  token       String   @unique
  format      String   @default("ics")
  filterTypes Json?
  isPublic    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  channel Channel? @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("calendar_subscriptions")
}

model EventReminder {
  id            String    @id @default(cuid())
  eventId       String
  userId        String
  type          String // notification, email, sms
  minutesBefore Int
  sent          Boolean   @default(false)
  sentAt        DateTime?
  createdAt     DateTime  @default(now())

  event CalendarEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([sent])
  @@index([userId])
  @@map("event_reminders")
}

model CalendarShare {
  id         String   @id @default(cuid())
  calendarId String
  entityType String // project, user
  sharedWith String // user ID
  permission String   @default("read")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [sharedWith], references: [id], onDelete: Cascade)

  @@unique([calendarId, entityType, sharedWith])
  @@index([sharedWith])
  @@map("calendar_shares")
}

model CalendarEvent {
  id          String   @id @default(cuid())
  projectId   String?
  taskId      String?
  creatorId   String
  title       String
  description String?  @db.Text
  type        String
  startDate   DateTime
  endDate     DateTime
  allDay      Boolean  @default(false)
  location    String?
  color       String?
  recurring   String?
  reminders   Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project   Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)
  task      Task?    @relation(fields: [taskId], references: [id], onDelete: SetNull)
  creator   User     @relation("EventCreator", fields: [creatorId], references: [id])
  attendees User[]   @relation("EventAttendees")

  syncs          CalendarSync[]
  eventReminders EventReminder[]

  @@map("calendar_events")
}

// ============================================
// NOTES MODELS
// ============================================

model NoteFolder {
  id        String   @id @default(cuid())
  name      String
  icon      String
  parentId  String?
  order     Int      @default(0)
  creatorId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  parent   NoteFolder?  @relation("FolderHierarchy", fields: [parentId], references: [id])
  children NoteFolder[] @relation("FolderHierarchy")
  creator  User         @relation(fields: [creatorId], references: [id])
  notes    Note[]

  @@map("note_folders")
}

model Note {
  id           String   @id @default(cuid())
  title        String
  content      String   @db.Text
  folderId     String
  creatorId    String
  isFavorite   Boolean  @default(false)
  template     Boolean  @default(false)
  encrypted    Boolean  @default(false)
  isPublic     Boolean  @default(false)
  workspaceId  String?
  createdAt    DateTime @default(now())
  lastModified DateTime @updatedAt

  folder    NoteFolder @relation(fields: [folderId], references: [id], onDelete: Cascade)
  workspace Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  creator   User       @relation("NoteCreator", fields: [creatorId], references: [id])

  tags          NoteTag[]
  collaborators User[]        @relation("NoteCollaborators")
  projects      Project[]     @relation("NoteLinkedProjects")
  tasks         Task[]        @relation("NoteLinkedTasks")
  attachments   Attachment[]
  versions      NoteVersion[]
  sourceLinks   NoteLink[]    @relation("SourceNote")
  targetLinks   NoteLink[]    @relation("TargetNote")

  @@map("notes")
}

model NoteTag {
  id     String @id @default(cuid())
  noteId String
  tag    String

  note Note @relation(fields: [noteId], references: [id], onDelete: Cascade)

  @@unique([noteId, tag])
  @@map("note_tags")
}

model NoteLink {
  id           String   @id @default(cuid())
  sourceNoteId String
  targetNoteId String
  type         String   @default("bidirectional")
  createdAt    DateTime @default(now())

  sourceNote Note @relation("SourceNote", fields: [sourceNoteId], references: [id], onDelete: Cascade)
  targetNote Note @relation("TargetNote", fields: [targetNoteId], references: [id], onDelete: Cascade)

  @@unique([sourceNoteId, targetNoteId])
  @@map("note_links")
}

model NoteVersion {
  id                String   @id @default(cuid())
  noteId            String
  content           String   @db.Text
  createdById       String?
  changeDescription String?
  createdAt         DateTime @default(now())

  note      Note  @relation(fields: [noteId], references: [id], onDelete: Cascade)
  createdBy User? @relation(fields: [createdById], references: [id], onDelete: SetNull)

  @@map("note_versions")
}

// ============================================
// INVITATION MODELS
// ============================================

model Invitation {
  id          String    @id @default(cuid())
  email       String
  token       String    @unique
  role        String    @default("member")
  invitedBy   String
  projectId   String?
  channelId   String?
  permissions Json?
  status      String    @default("pending") // pending, accepted, declined, expired
  expiresAt   DateTime
  acceptedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  inviter User     @relation("InvitedBy", fields: [invitedBy], references: [id])
  project Project? @relation("ProjectInvitations", fields: [projectId], references: [id], onDelete: Cascade)
  channel Channel? @relation(fields: [channelId], references: [id], onDelete: Cascade)

  logs InvitationLog[]

  @@index([email])
  @@map("invitations")
}

model InvitationLog {
  id           String   @id @default(cuid())
  invitationId String
  action       String // sent, resent, accepted, expired, cancelled
  metadata     Json?
  createdAt    DateTime @default(now())

  invitation Invitation @relation(fields: [invitationId], references: [id], onDelete: Cascade)

  @@index([invitationId])
  @@map("invitation_logs")
}

// ============================================
// API KEY & WEBHOOK MODELS
// ============================================

model ApiKey {
  id          String    @id @default(cuid())
  name        String
  key         String    @unique
  userId      String
  permissions Json
  rateLimit   Int       @default(1000)
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([key])
  @@index([userId])
  @@map("api_keys")
}

model Webhook {
  id          String    @id @default(cuid())
  name        String
  url         String
  secret      String
  events      Json
  userId      String
  isActive    Boolean   @default(true)
  lastFiredAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  logs WebhookLog[]

  @@index([userId])
  @@map("webhooks")
}

model WebhookLog {
  id         String   @id @default(cuid())
  webhookId  String
  event      String
  payload    Json
  response   String?
  statusCode Int?
  success    Boolean
  error      String?  @db.Text
  createdAt  DateTime @default(now())

  webhook Webhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  @@index([webhookId])
  @@index([createdAt])
  @@map("webhook_logs")
}

model Notification {
  id         String   @id @default(cuid())
  userId     String
  type       String
  title      String
  message    String   @db.Text
  entityType String?
  entityId   String?
  linkUrl    String?
  isRead     Boolean  @default(false)
  metadata   Json?
  createdAt  DateTime @default(now())

  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  pushNotificationLogs PushNotificationLog[]

  @@index([userId, isRead])
  @@map("notifications")
}

model ActivityLog {
  id         String   @id @default(cuid())
  userId     String
  action     String
  entityType String
  entityId   String
  metadata   Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("activity_logs")
}

// ============================================
// AI ASSISTANT MODELS
// ============================================

model AssistantConversation {
  id         String   @id @default(cuid())
  userId     String
  title      String
  context    Json?
  settings   Json?
  isArchived Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user     User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages AssistantMessage[]
  tools    AssistantToolUsage[]

  @@index([userId])
  @@map("assistant_conversations")
}

model AssistantMessage {
  id             String   @id @default(cuid())
  conversationId String
  role           String
  content        String   @db.Text
  toolCalls      Json?
  toolResults    Json?
  tokens         Int?
  model          String?
  createdAt      DateTime @default(now())

  conversation AssistantConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@map("assistant_messages")
}

model AssistantToolUsage {
  id             String   @id @default(cuid())
  conversationId String
  toolName       String
  parameters     Json
  result         Json?
  success        Boolean
  errorMessage   String?  @db.Text
  executionTime  Int?
  createdAt      DateTime @default(now())

  conversation AssistantConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([toolName])
  @@map("assistant_tool_usage")
}

model AssistantAuditLog {
  id           String   @id @default(cuid())
  userId       String
  action       String
  resourceType String?
  resourceId   String?
  query        String?  @db.Text
  response     String?  @db.Text
  metadata     Json?
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([resourceType, resourceId])
  @@index([createdAt])
  @@map("assistant_audit_logs")
}

// ============================================
// SCHEDULED NOTIFICATION MODELS
// ============================================

model ScheduledNotification {
  id           String    @id @default(cuid())
  userId       String
  title        String
  message      String    @db.Text
  scheduleType String
  scheduledFor DateTime
  timezone     String    @default("UTC")
  recurrence   Json?
  isActive     Boolean   @default(true)
  isSent       Boolean   @default(false)
  sentAt       DateTime?
  entityType   String?
  entityId     String?
  linkUrl      String?
  metadata     Json?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user    User                           @relation(fields: [userId], references: [id], onDelete: Cascade)
  history ScheduledNotificationHistory[]

  @@index([userId])
  @@index([scheduledFor])
  @@index([isActive, isSent])
  @@map("scheduled_notifications")
}

model ScheduledNotificationHistory {
  id                      String                @id @default(cuid())
  scheduledNotificationId String
  sentAt                  DateTime
  success                 Boolean
  errorMessage            String?               @db.Text
  metadata                Json?
  scheduledNotification   ScheduledNotification @relation(fields: [scheduledNotificationId], references: [id], onDelete: Cascade)

  @@index([scheduledNotificationId])
  @@map("scheduled_notification_history")
}

// ============================================
// DEVICE TOKEN MODELS
// ============================================

model DeviceToken {
  id         String   @id @default(cuid())
  userId     String
  platform   String
  token      String   @unique
  deviceInfo Json?
  isActive   Boolean  @default(true)
  lastUsedAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([platform])
  @@index([token])
  @@map("device_tokens")
}

model PushNotificationLog {
  id             String   @id @default(cuid())
  userId         String
  notificationId String?
  platform       String
  deviceToken    String
  title          String
  body           String
  data           Json?
  status         String // sent, failed, delivered
  error          String?  @db.Text
  sentAt         DateTime @default(now())

  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  notification Notification? @relation(fields: [notificationId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([notificationId])
  @@index([status])
  @@map("push_notification_logs")
}

// ============================================
// CALL MODELS
// ============================================

model Call {
  id           String            @id @default(cuid())
  channelName  String
  type         String // voice, video
  initiatorId  String?
  status       String            @default("pending") // pending, active, ended, missed
  startedAt    DateTime          @default(now())
  endedAt      DateTime?
  duration     Int?
  agoraToken   String?           @db.Text
  metadata     Json?
  participants CallParticipant[]
  initiator    User?             @relation(fields: [initiatorId], references: [id], onDelete: SetNull)

  @@index([channelName])
  @@index([initiatorId])
  @@index([status])
  @@map("calls")
}

model CallParticipant {
  id       String    @id @default(cuid())
  callId   String
  userId   String
  joinedAt DateTime  @default(now())
  leftAt   DateTime?
  role     String    @default("participant") // host, participant
  muted    Boolean   @default(false)
  videoOff Boolean   @default(false)

  call Call @relation(fields: [callId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([callId, userId])
  @@index([callId])
  @@index([userId])
  @@map("call_participants")
}

model CustomEmoji {
  id          String   @id @default(cuid())
  name        String
  shortcode   String // e.g., :custom_emoji:
  imageUrl    String
  animated    Boolean  @default(false)
  workspaceId String?
  createdById String
  category    String   @default("custom")
  isGlobal    Boolean  @default(false) // Available across all workspaces
  usageCount  Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  workspace Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  reactions Reaction[]

  @@unique([shortcode, workspaceId])
  @@map("custom_emojis")
}

// ============================================
// USER BADGE MODELS
// ============================================

model UserBadge {
  id          String   @id @default(cuid())
  name        String
  description String?
  icon        String // Emoji or icon name
  color       String // Badge color
  bgColor     String // Background color
  tier        String   @default("standard") // standard, premium, elite, legendary
  category    String   @default("achievement") // achievement, role, special, event
  isGlobal    Boolean  @default(false)
  workspaceId String?
  createdById String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  workspace  Workspace?            @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  userBadges UserBadgeAssignment[]

  @@map("user_badges")
}

model UserBadgeAssignment {
  id         String   @id @default(cuid())
  userId     String
  badgeId    String
  assignedBy String
  reason     String?
  isPrimary  Boolean  @default(false) // Show as primary badge
  isVisible  Boolean  @default(true)
  earnedAt   DateTime @default(now())

  badge UserBadge @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  @@map("user_badge_assignments")
}

// ============================================
// CHANNEL WEBHOOK MODELS
// ============================================

model ChannelWebhook {
  id          String    @id @default(cuid())
  channelId   String
  name        String
  url         String
  secret      String
  events      Json // Array of events: ["message.created", "message.updated", "message.deleted", "member.added", "member.removed"]
  isActive    Boolean   @default(true)
  createdBy   String
  lastFiredAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  channel Channel             @relation(fields: [channelId], references: [id], onDelete: Cascade)
  creator User                @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  logs    ChannelWebhookLog[]

  @@index([channelId])
  @@map("channel_webhooks")
}

model ChannelWebhookLog {
  id        String   @id @default(cuid())
  webhookId String
  event     String
  payload   Json
  status    Int
  response  String?
  createdAt DateTime @default(now())

  webhook ChannelWebhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  @@index([webhookId])
  @@map("channel_webhook_logs")
}


model ChannelIncomingWebhook {
  id              String   @id @default(cuid())
  channelId       String
  name            String
  description     String?
  token           String   @unique
  secret          String
  isActive        Boolean  @default(true)
  createdBy       String
  lastReceivedAt  DateTime?
  totalReceived   Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  creator User    @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  logs    ChannelIncomingWebhookLog[]

  @@index([channelId])
  @@index([token])
  @@map("channel_incoming_webhooks")
}

model ChannelIncomingWebhookLog {
  id        String   @id @default(cuid())
  webhookId String
  payload   Json
  status    Int
  response  String?
  createdAt DateTime @default(now())

  webhook ChannelIncomingWebhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  @@index([webhookId])
  @@map("channel_incoming_webhook_logs")
}


model Friend {
  id        String   @id @default(cuid())
  userId    String
  friendId  String
  nickname  String? // Optional custom nickname for the friend
  createdAt DateTime @default(now())

  user   User @relation("UserFriends", fields: [userId], references: [id], onDelete: Cascade)
  friend User @relation("FriendOf", fields: [friendId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
  @@index([userId])
  @@index([friendId])
  @@map("friends")
}

model FriendRequest {
  id          String    @id @default(cuid())
  senderId    String
  receiverId  String
  status      String    @default("pending") // pending, accepted, declined, cancelled
  message     String?   @db.Text // Optional message with the request
  createdAt   DateTime  @default(now())
  respondedAt DateTime?

  sender   User @relation("SentFriendRequests", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("ReceivedFriendRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([senderId])
  @@index([receiverId])
  @@index([status])
  @@map("friend_requests")
}
